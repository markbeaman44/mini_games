<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cake Factory - Sweet Adventures</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
            height: 100vh;
            height: 100dvh;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #backButton {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 700;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
            z-index: 1000;
        }

        #backButton:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        .game-container {
            width: min(900px, 95vw);
            height: min(600px, 85vh);
            position: relative;
            background: linear-gradient(180deg, #87CEEB 0%, #FFF8DC 60%, #F4A460 100%);
            border-radius: 20px;
            border: 4px solid rgba(255,255,255,0.6);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 16px;
        }

        .hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            padding: 10px;
            font-weight: bold;
            color: #8B4513;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,182,193,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            z-index: 10;
        }

        .start-screen h1 {
            font-size: 3rem;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.5);
        }

        .start-screen p {
            font-size: 1.2rem;
            color: #654321;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }

        .start-btn {
            background: linear-gradient(45deg, #FF69B4, #FFB6C1);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139,69,19,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            z-index: 15;
            color: white;
        }

        .game-over h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-over p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.8);
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            user-select: none;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .instructions-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 16px;
        }

        .instructions-content {
            background: linear-gradient(135deg, #FFB6C1, #FFF8DC);
            border-radius: 15px;
            padding: 20px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8B4513;
        }

        .instructions-content h2 {
            color: #8B4513;
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }

        .instructions-list {
            text-align: left;
            margin: 15px 0;
            color: #654321;
            font-size: 1rem;
            line-height: 1.4;
            list-style: none;
        }

        .instructions-list li {
            margin: 8px 0;
            padding-left: 5px;
        }

        .controls-info {
            background: rgba(255,255,255,0.7);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            color: #8B4513;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .close-instructions {
            background: linear-gradient(45deg, #FF69B4, #FFB6C1);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
            margin-top: 10px;
        }

        .close-instructions:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 600px) {
            .controls {
                display: flex;
            }
            
            .instructions-content {
                margin: 20px;
                padding: 20px;
                max-width: 90%;
            }
            
            .instructions-content h2 {
                font-size: 1.5rem;
            }
            
            .instructions-list {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <button id="backButton">‚Üê Back to Hub</button>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <div class="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Cakes: <span id="cakes">0</span></div>
        </div>

        <div class="start-screen" id="startScreen">
            <h1>üéÇ Cake Factory</h1>
            <p>Be a master baker! Catch falling cake layers and decorations to build towering cakes. Stack them perfectly and create 5 beautiful desserts to complete the level!</p>
            <button class="start-btn" id="startBtn">Start Baking!</button>
        </div>

        <div class="game-over" id="gameOver">
            <h2>üç∞ Sweet Adventure Complete!</h2>
            <p id="finalScore">Final Score: 0</p>
            <button class="start-btn" id="restartBtn">Bake Again!</button>
        </div>

        <div class="instructions-modal" id="instructionsModal">
            <div class="instructions-content">
                <h2>üéÇ How to Play</h2>
                <div class="controls-info">
                    <strong>Controls:</strong> ‚Üê ‚Üí Arrow Keys or A/D to move
                </div>
                <ul class="instructions-list">
                    <li>üç´ <strong>Catch cake layers</strong> to build your cakes</li>
                    <li>üçí <strong>Catch decorations</strong> to add toppings</li>
                    <li>üéØ <strong>Build 4-layer cakes with decorations</strong> to complete them</li>
                    <li>üì¶ <strong>Completed cakes</strong> move on conveyor belt</li>
                    <li>üèÜ <strong>Complete 5 cakes</strong> to win the level!</li>
                </ul>
                <button class="close-instructions" id="closeInstructions">Start Baking! üßÅ</button>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" id="leftBtn">‚¨ÖÔ∏è</button>
            <button class="control-btn" id="upBtn">‚¨ÜÔ∏è</button>
            <button class="control-btn" id="rightBtn">‚û°Ô∏è</button>
            <button class="control-btn" id="downBtn">‚¨áÔ∏è</button>
        </div>
    </div>

    <script>
        (function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOver');
            const instructionsModal = document.getElementById('instructionsModal');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const closeInstructionsBtn = document.getElementById('closeInstructions');
            const backBtn = document.getElementById('backButton');
            
            // Mobile controls
            const leftBtn = document.getElementById('leftBtn');
            const upBtn = document.getElementById('upBtn');
            const rightBtn = document.getElementById('rightBtn');
            const downBtn = document.getElementById('downBtn');

            // Game state
            let gameRunning = false;
            let gameStarted = false;
            let score = 0;
            let cakesCompleted = 0;
            let frame = 0;
            
            // Baker character (player)
            let baker = {
                x: canvas.width / 2 - 25,
                y: canvas.height - 80,
                width: 50,
                height: 60,
                speed: 6,
                vx: 0
            };

            // Game objects
            let fallingItems = [];
            let cakeStack = [];
            let currentCake = { layers: [], x: canvas.width / 2, baseY: canvas.height - 40 };
            let particles = [];
            let conveyorBelt = { x: 0, speed: 1 };

            // Input handling
            let keys = {};
            let touches = {};

            // Cake building system
            const cakeLayerTypes = [
                { type: 'chocolate', color: '#8B4513', emoji: 'üç´', height: 15 },
                { type: 'vanilla', color: '#FFF8DC', emoji: 'ü•õ', height: 15 },
                { type: 'strawberry', color: '#FFB6C1', emoji: 'üçì', height: 15 },
                { type: 'sponge', color: '#F0E68C', emoji: 'üßΩ', height: 20 }
            ];

            const decorations = [
                { type: 'cherry', emoji: 'üçí', color: '#DC143C', points: 50 },
                { type: 'candle', emoji: 'üïØÔ∏è', color: '#FFD700', points: 30 },
                { type: 'flower', emoji: 'üå∏', color: '#FFB6C1', points: 40 },
                { type: 'star', emoji: '‚≠ê', color: '#FFD700', points: 60 }
            ];

            const badItems = [
                { type: 'rock', emoji: 'ÔøΩ', color: '#696969' },
                { type: 'fire', emoji: 'üî•', color: '#FF4500' },
                { type: 'bomb', emoji: 'üí£', color: '#000000' }
            ];

            // Spawn falling items
            function spawnFallingItem() {
                if (Math.random() < 0.7) {
                    // Spawn cake layer
                    const layer = cakeLayerTypes[Math.floor(Math.random() * cakeLayerTypes.length)];
                    fallingItems.push({
                        x: Math.random() * (canvas.width - 60),
                        y: -40,
                        width: 60,
                        height: layer.height + 5,
                        type: 'layer',
                        layerType: layer.type,
                        color: layer.color,
                        emoji: layer.emoji,
                        vy: 1 + Math.random() * 1
                    });
                } else {
                    // Spawn decoration
                    const decoration = decorations[Math.floor(Math.random() * decorations.length)];
                    fallingItems.push({
                        x: Math.random() * (canvas.width - 50),
                        y: -40,
                        width: 50,
                        height: 50,
                        type: 'decoration',
                        decorationType: decoration.type,
                        color: decoration.color,
                        emoji: decoration.emoji,
                        points: decoration.points,
                        vy: 1 + Math.random() * 1
                    });
                }
            }

            // Update baker
            function updateBaker() {
                // Handle input
                if (keys['ArrowLeft'] || keys['a'] || touches['left']) {
                    baker.vx = -baker.speed;
                } else if (keys['ArrowRight'] || keys['d'] || touches['right']) {
                    baker.vx = baker.speed;
                } else {
                    baker.vx *= 0.8; // Friction
                }

                // Update position
                baker.x += baker.vx;

                // Keep baker in bounds
                if (baker.x < 0) baker.x = 0;
                if (baker.x + baker.width > canvas.width) baker.x = canvas.width - baker.width;
            }

            // Update falling items
            function updateFallingItems() {
                for (let i = fallingItems.length - 1; i >= 0; i--) {
                    let item = fallingItems[i];
                    item.y += item.vy;

                    // Check collision with baker
                    if (item.x < baker.x + baker.width &&
                        item.x + item.width > baker.x &&
                        item.y < baker.y + baker.height &&
                        item.y + item.height > baker.y) {
                        
                        catchItem(item);
                        fallingItems.splice(i, 1);
                        continue;
                    }

                    // Remove items that fell off screen
                    if (item.y > canvas.height) {
                        // Penalty for missing good items
                        score = Math.max(0, score - 5);
                        fallingItems.splice(i, 1);
                    }
                }
            }

            // Handle catching items
            function catchItem(item) {
                if (item.type === 'layer') {
                    addLayerToCake(item);
                    score += 20;
                    createCatchParticles(item.x, item.y, item.color);
                    playSound(440, 0.1);
                } else if (item.type === 'decoration') {
                    addDecorationToCake(item);
                    score += item.points;
                    createCatchParticles(item.x, item.y, item.color);
                    playSound(660, 0.15);
                }
            }

            // Add layer to current cake
            function addLayerToCake(layer) {
                // Collect all decorations from existing layers
                let allDecorations = [];
                for (let existingLayer of currentCake.layers) {
                    allDecorations = allDecorations.concat(existingLayer.decorations);
                    existingLayer.decorations = []; // Clear decorations from existing layers
                }
                
                const newLayer = {
                    type: layer.layerType,
                    color: layer.color,
                    emoji: layer.emoji,
                    height: layer.height,
                    width: 60 - currentCake.layers.length * 2, // Layers get smaller as cake gets taller
                    decorations: allDecorations // Move all decorations to the new top layer
                };
                
                // Adjust decoration positions for the new layer width
                for (let decoration of newLayer.decorations) {
                    decoration.x = Math.min(decoration.x, newLayer.width - 20);
                }
                
                currentCake.layers.push(newLayer);

                // Check if cake is complete (4 layers AND at least 1 decoration)
                if (currentCake.layers.length >= 4 && hasDecorations()) {
                    completeCake();
                }
            }

            // Check if cake has any decorations
            function hasDecorations() {
                return currentCake.layers.some(layer => layer.decorations.length > 0);
            }

            // Add decoration to top layer
            function addDecorationToCake(decoration) {
                if (currentCake.layers.length > 0) {
                    const topLayer = currentCake.layers[currentCake.layers.length - 1];
                    topLayer.decorations.push({
                        type: decoration.decorationType,
                        emoji: decoration.emoji,
                        color: decoration.color,
                        x: Math.random() * (topLayer.width - 20) + 10
                    });
                    
                    // Check if cake is now complete (4 layers AND at least 1 decoration)
                    if (currentCake.layers.length >= 4 && hasDecorations()) {
                        completeCake();
                    }
                } else {
                    // No layers to decorate, just give points
                    score += Math.floor(decoration.points / 2);
                }
            }

            // Complete current cake and start new one
            function completeCake() {
                cakesCompleted++;
                score += 100 + (currentCake.layers.length * 20);
                
                // Move completed cake to conveyor belt
                cakeStack.push({
                    layers: [...currentCake.layers],
                    x: canvas.width + 100,
                    y: currentCake.baseY - (currentCake.layers.length * 15),
                    completed: true
                });

                // Reset current cake
                currentCake.layers = [];
                
                createCompletionParticles();
                playSound(523, 0.4);
                
                // Check if player has completed 5 cakes
                if (cakesCompleted >= 5) {
                    endGame();
                }
            }

            // Update conveyor belt and completed cakes
            function updateConveyorBelt() {
                conveyorBelt.x += conveyorBelt.speed;
                if (conveyorBelt.x > 40) conveyorBelt.x = 0;

                // Move completed cakes on conveyor
                for (let i = cakeStack.length - 1; i >= 0; i--) {
                    let cake = cakeStack[i];
                    cake.x -= conveyorBelt.speed * 2;
                    
                    // Remove cakes that moved off screen
                    if (cake.x < -100) {
                        cakeStack.splice(i, 1);
                    }
                }
            }

            // Particle effects
            function createCatchParticles(x, y, color) {
                for (let i = 0; i < 6; i++) {
                    particles.push({
                        x: x + 15,
                        y: y + 15,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 30,
                        color: color
                    });
                }
            }

            function createCompletionParticles() {
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: currentCake.x,
                        y: currentCake.baseY - 60,
                        vx: (Math.random() - 0.5) * 6,
                        vy: Math.random() * -4 - 2,
                        life: 60,
                        color: ['#FFD700', '#FF69B4', '#87CEEB'][Math.floor(Math.random() * 3)]
                    });
                }
            }

            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    let particle = particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
            }

            // Audio
            function playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    // Audio not supported
                }
            }

            // Drawing functions
            function drawBackground() {
                // Kitchen background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.6, '#FFF8DC');
                gradient.addColorStop(1, '#F4A460');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Conveyor belt at bottom
                ctx.fillStyle = '#696969';
                ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
                
                // Conveyor belt pattern
                ctx.fillStyle = '#808080';
                for (let x = conveyorBelt.x; x < canvas.width; x += 40) {
                    ctx.fillRect(x, canvas.height - 25, 20, 20);
                }

                // Work counter
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(canvas.width / 2 - 100, canvas.height - 50, 200, 20);
            }

            function drawBaker() {
                ctx.save();
                ctx.translate(baker.x + baker.width / 2, baker.y + baker.height / 2);
                
                // Baker body
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-20, -25, 40, 35);
                
                // Baker apron
                ctx.fillStyle = '#FFB6C1';
                ctx.fillRect(-15, -20, 30, 30);
                
                // Baker hat
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-18, -35, 36, 15);
                ctx.fillRect(-12, -40, 24, 8);
                
                // Baker face
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(-12, -30, 24, 20);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(-8, -25, 3, 3);
                ctx.fillRect(5, -25, 3, 3);
                
                // Smile
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, -18, 6, 0, Math.PI);
                ctx.stroke();
                
                ctx.restore();
            }

            function drawFallingItems() {
                ctx.font = '32px Arial';
                for (let item of fallingItems) {
                    // Draw shadow for depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(item.x + 3, item.y + 3, item.width, item.height);
                    
                    // Draw item background with border
                    ctx.fillStyle = item.color;
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    
                    // Draw border
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(item.x, item.y, item.width, item.height);
                    
                    // Draw emoji larger and centered
                    ctx.fillStyle = '#000';
                    const emojiX = item.x + (item.width - 25) / 2;
                    const emojiY = item.y + (item.height + 20) / 2;
                    ctx.fillText(item.emoji, emojiX, emojiY);
                }
            }

            function drawCurrentCake() {
                if (currentCake.layers.length === 0) return;
                
                let yOffset = 0;
                for (let i = 0; i < currentCake.layers.length; i++) {
                    const layer = currentCake.layers[i];
                    const layerY = currentCake.baseY - yOffset - layer.height;
                    const layerX = currentCake.x - layer.width / 2;
                    
                    // Draw layer
                    ctx.fillStyle = layer.color;
                    ctx.fillRect(layerX, layerY, layer.width, layer.height);
                    
                    // Draw layer border
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(layerX, layerY, layer.width, layer.height);
                    
                    // Draw decorations on this layer
                    ctx.font = '16px Arial';
                    for (let decoration of layer.decorations) {
                        ctx.fillText(decoration.emoji, layerX + decoration.x, layerY - 5);
                    }
                    
                    yOffset += layer.height;
                }
            }

            function drawCompletedCakes() {
                for (let cake of cakeStack) {
                    let yOffset = 0;
                    for (let layer of cake.layers) {
                        const layerY = cake.y - yOffset;
                        const layerX = cake.x - layer.width / 2;
                        
                        // Draw layer
                        ctx.fillStyle = layer.color;
                        ctx.fillRect(layerX, layerY, layer.width, layer.height);
                        
                        // Draw decorations
                        ctx.font = '12px Arial';
                        for (let decoration of layer.decorations) {
                            ctx.fillText(decoration.emoji, layerX + decoration.x, layerY - 2);
                        }
                        
                        yOffset += layer.height;
                    }
                }
            }

            function drawParticles() {
                for (let particle of particles) {
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.life / 60;
                    ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                }
                ctx.globalAlpha = 1;
            }

            function drawUI() {
                // Current cake progress indicator
                if (currentCake.layers.length > 0) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fillRect(10, 10, 250, 50);
                    ctx.fillStyle = '#8B4513';
                    ctx.font = '16px Arial';
                    ctx.fillText(`Cake Progress: ${currentCake.layers.length}/4 layers`, 15, 30);
                    
                    const hasDecos = hasDecorations();
                    ctx.fillStyle = hasDecos ? '#228B22' : '#8B4513';
                    ctx.fillText(`Decorations: ${hasDecos ? '‚úì' : 'Need 1+'}`, 15, 50);
                }
            }

            // Game logic
            function startGame() {
                gameRunning = true;
                gameStarted = true;
                score = 0;
                cakesCompleted = 0;
                frame = 0;
                
                baker.x = canvas.width / 2 - 25;
                baker.vx = 0;
                
                fallingItems = [];
                cakeStack = [];
                currentCake = { layers: [], x: canvas.width / 2, baseY: canvas.height - 40 };
                particles = [];
                conveyorBelt = { x: 0, speed: 1 };
                
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                instructionsModal.style.display = 'none';
                
                updateHUD();
                gameLoop();
            }

            function showInstructions() {
                instructionsModal.style.display = 'flex';
                startScreen.style.display = 'none';
            }

            function hideInstructions() {
                instructionsModal.style.display = 'none';
                startScreen.style.display = 'flex';
            }

            function endGame() {
                gameRunning = false;
                document.getElementById('finalScore').textContent = `Final Score: ${score} | Cakes Made: ${cakesCompleted}/5`;
                gameOverScreen.style.display = 'flex';
                
                // Save high score
                const highScore = parseInt(localStorage.getItem('cakeFactoryBest') || '0');
                if (score > highScore) {
                    localStorage.setItem('cakeFactoryBest', score.toString());
                }
            }

            function updateHUD() {
                document.getElementById('score').textContent = score;
                document.getElementById('cakes').textContent = `${cakesCompleted}/5`;
            }

            function update() {
                if (!gameRunning) return;
                
                frame++;
                
                // Spawn falling items
                if (frame % (30 + Math.floor(Math.random() * 30)) === 0) {
                    spawnFallingItem();
                }
                
                updateBaker();
                updateFallingItems();
                updateConveyorBelt();
                updateParticles();
                updateHUD();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawBackground();
                drawCompletedCakes();
                drawCurrentCake();
                drawFallingItems();
                drawParticles();
                drawBaker();
                drawUI();
            }

            function gameLoop() {
                if (gameRunning) {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                }
            }

            // Event listeners
            startBtn.addEventListener('click', showInstructions);
            restartBtn.addEventListener('click', startGame);
            closeInstructionsBtn.addEventListener('click', startGame);
            backBtn.addEventListener('click', () => {
                window.location.href = 'home.html';
            });

            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                keys[e.code] = true;
                
                if (e.key === ' ') e.preventDefault();
                
                if (!gameStarted && (e.key === ' ' || e.key === 'Enter')) {
                    if (instructionsModal.style.display === 'flex') {
                        startGame();
                    } else {
                        showInstructions();
                    }
                } else if (!gameRunning && gameStarted && (e.key === ' ' || e.key === 'Enter')) {
                    // Restart game when it's over
                    startGame();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                keys[e.code] = false;
            });

            // Touch controls
            function setupTouchControls() {
                leftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touches['left'] = true;
                });
                leftBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touches['left'] = false;
                });

                rightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touches['right'] = true;
                });
                rightBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touches['right'] = false;
                });

                upBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touches['up'] = true;
                });
                upBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touches['up'] = false;
                });

                downBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touches['down'] = true;
                });
                downBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    touches['down'] = false;
                });
            }

            // Initialize
            setupTouchControls();
            
            // Show instructions on load
            setTimeout(() => {
                showInstructions();
            }, 500);
            
            draw(); // Initial draw
        })();

        window.addEventListener("load", function() {
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 100);
        });
    </script>
</body>
</html>
